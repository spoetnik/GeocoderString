<?php namespace ProcessWire;

/**
 * GeocoderString.module
 *
 * Geocode a string or coordinates using the same provider/configuration that
 * the FieldtypeGeocoder module uses internally.
 *
 * Depends on FieldtypeGeocoder and re-uses its adapter/provider/geocoder setup.
 */
class GeocoderString extends WireData implements Module {

    public static function getModuleInfo() {
        return [
            'title' => 'GeocoderString',
            'version' => 1,
            'summary' => 'Geocode an arbitrary string or coordinates using FieldtypeGeocoder configuration',
            'author' => 'Spoetnik',
			'href' => 'https://github.com/spoetnik/GeocoderString',
			'icon' => 'globe',            
            'requires' => ['FieldtypeGeocoder'],
            'singular' => true,
            'autoload' => true,
        ];
    }

    /** @var FieldtypeGeocoder */
    protected $fieldtypeGeocoder;

    /** @var \Geocoder\StatefulGeocoder */
    protected $geocoder;

    /** Initialize and reuse FieldtypeGeocoder's setup */
    public function init() {
        $this->fieldtypeGeocoder = $this->modules->get('FieldtypeGeocoder');
        if (!$this->fieldtypeGeocoder) {
            throw new WireException("GeocoderString requires the FieldtypeGeocoder module to be installed.");
        }

        // Load geocoder-php (same as FieldtypeGeocoder does)
        $this->fieldtypeGeocoder->loadGeocoderPhp();

        // Build adapter / provider / geocoder exactly like FieldtypeGeocoder::update()
        $adapter = $this->fieldtypeGeocoder->getAdapter();
        if (!$adapter) {
            throw new WireException("FieldtypeGeocoder: getAdapter() returned null.");
        }

        // IMPORTANT: getProvider requires the adapter argument â€” do NOT call with zero args
        $provider = $this->fieldtypeGeocoder->getProvider($adapter);
        if (!$provider) {
            throw new WireException("FieldtypeGeocoder: provider could not be created. Check FieldtypeGeocoder configuration.");
        }

        $geocoder = $this->fieldtypeGeocoder->getGeocoder($provider);
        if (!$geocoder) {
            throw new WireException("FieldtypeGeocoder: geocoder instance could not be created.");
        }

        $this->geocoder = $geocoder;
    }

    /**
     * Geocode a free-form address string.
     *
     * @param string $string Address or place string (e.g. "1017 XE Amsterdam")
     * @param array $options Optional flags. Supported: ['country' => 'NL']
     * @return array|null ['lat'=>float, 'lng'=>float, 'formatted_address'=>string] or null on not found/error
     */
    public function geocode(string $string, array $options = []) {
        if (!$this->geocoder) return null;

        try {
            $queryText = $string;
            if (!empty($options['country'])) {
                $queryText .= ', ' . $options['country'];
            }

            // Create query directly without filterQuery() which requires field context
            $q = \Geocoder\Query\GeocodeQuery::create($queryText);
            
            // NOTE: We skip filterQuery() because it may access field-specific database tables
            // If you need to apply filterQuery hooks, you'll need to create an actual field instance

            $collection = $this->geocoder->geocodeQuery($q);
            if ($collection->isEmpty()) return null;

            $location = $collection->first();
            $coords = $location->getCoordinates();

            return [
                'lat' => $coords ? $coords->getLatitude() : null,
                'lng' => $coords ? $coords->getLongitude() : null,
                'formatted_address' => $this->formatLocationAddress($location)
            ];
        } catch (\Throwable $e) {
            $this->wire('log')->save("GeocoderString::geocode error: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Reverse-geocode coordinates to a formatted address.
     *
     * @param float $lat
     * @param float $lng
     * @return array|null ['formatted_address' => string] or null
     */
    public function reverseGeocode(float $lat, float $lng) {
        if (!$this->geocoder) return null;

        try {
            $rq = \Geocoder\Query\ReverseQuery::fromCoordinates($lat, $lng);
            
            // NOTE: Skip filterQuery() to avoid field context dependency

            $collection = $this->geocoder->reverseQuery($rq);
            if ($collection->isEmpty()) return null;

            $location = $collection->first();

            return [
                'formatted_address' => $this->formatLocationAddress($location)
            ];
        } catch (\Throwable $e) {
            $this->wire('log')->save("GeocoderString::reverseGeocode error: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Format a Location object into a human-readable address string.
     * This avoids calling FieldtypeGeocoder::formatAddress() which requires database access.
     *
     * @param \Geocoder\Model\Address $location
     * @return string
     */
    protected function formatLocationAddress($location) {
        // Build address from Location object components
        $parts = array_filter([
            $location->getStreetNumber(),
            $location->getStreetName(),
            $location->getPostalCode(),
            $location->getLocality(),
            $location->getSubLocality(),
            $location->getCountry() ? $location->getCountry()->getName() : null,
        ]);

        return implode(', ', $parts) ?: 'Unknown location';
    }
}